"""
什么是桶排序？
桶排序，或称为bin排序，是一种排序算法，其工作原理是将数组的元素分布在多个
桶中。然后，每个桶被单独地排序，不管是使用不同的排序算法还是递归地应用桶
排序算法。它是一种分布排序，是鸽子洞排序的一种推广/归纳结果，是基数排序
（Radix Sort）的一种表型。桶排序可以通过比较实现，因此也可以看作是比较排
序算法。计算复杂度涉及到桶的数量。
桶排序的工作步骤如下4步：
1.创建一个数组，里面是各个初始为空的“桶”。
2.分散：遍历原始数组，将每个对象放入对应的桶中。
3.对每个非空桶进行排序。
4.收集，按顺序访问桶，并将所有元素放回原始数组中。
实例分析
假设我们有一组输入数组A{29，25，3，49，9，37，21，43}。我们需要把这些数据
从小到大排列出来。这些数组里面最大的数据是49。
第一步，创建空桶，我们现在要做的就是设置几个桶，这些桶可以是一个桶代表一个
数据，从0排到49一共50个桶，也可以一个桶代表一组范围，比如0-9，10-19，30-39，
40-49，一共5个桶。这里我们选择第二个分法。
第二步，分散。我们开始遍历原始数组，将每个元素放入对应的桶中，那么，0-9的
桶中有3，9；10-19的桶中没有元素；20-29的桶中有29，25，21；30-39的桶中有37；
40-49的桶中有49，43。
第三步，对每个非空桶进行排序。除了10-19桶，其余的桶都是非空的。0-9的桶中排
序后还是3再是9；20-29的桶中排序后是21，25，29；30-39的桶中排序后是37因为只
有一个元素，40-49的桶中排序后是43，49。
第四步，收集。按顺序访问桶，并将所有元素放回到输出数组中。先0-9的桶，再10-19
的桶，20-29的桶，30-39的桶，最后是40-49的桶。最终的目标就变成了
{3，9，21，25，29，37，43，49}
"""


def bucket_sort(nums):
    buckets = [0] * (max(nums) - min(nums) + 1)
    for i in nums:
        buckets[i - min(nums)] += 1
    index = 0
    for i in range(len(buckets)):
        while buckets[i] > 0:
            nums[index] = i + min(nums)
            index, buckets[i] = index + 1, buckets[i] - 1
    return nums


if __name__ == "__main__":
    nums = [2, 20, 1, 88, 34, 23]
    print(bucket_sort(nums))


